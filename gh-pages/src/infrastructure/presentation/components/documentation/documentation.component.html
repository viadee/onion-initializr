<div class="documentation-container">
  <!-- Header Section -->
  <header class="doc-header">
    <div class="header-content">
      <div class="header-left">
        <h1 class="doc-title">Onion Initializr Documentation</h1>
        <p class="doc-subtitle">
          Complete guide to generating onion architecture projects
        </p>
      </div>
      <div class="header-right">
        <button (click)="navigateHome()" class="back-button">
          <span class="back-icon">←</span>
          Back to Home
        </button>
      </div>
    </div>
  </header>

  <!-- Navigation Sidebar -->
  <nav class="doc-navigation">
    <div class="nav-content">
      <h3>Table of Contents</h3>
      <ul class="nav-list">
        <li>
          <a
            (click)="scrollToSection('overview')"
            class="nav-link"
            style="cursor: pointer"
            >Overview</a
          >
        </li>
        <li>
          <a
            (click)="scrollToSection('getting-started')"
            class="nav-link"
            style="cursor: pointer"
            >Getting Started</a
          >
        </li>
        <li>
          <a
            (click)="scrollToSection('architecture')"
            class="nav-link"
            style="cursor: pointer"
            >Architecture Principles</a
          >
        </li>
        <li>
          <a
            (click)="scrollToSection('entities')"
            class="nav-link"
            style="cursor: pointer"
            >Entities</a
          >
        </li>
        <li>
          <a
            (click)="scrollToSection('services')"
            class="nav-link"
            style="cursor: pointer"
            >Services</a
          >
        </li>
        <li>
          <a
            (click)="scrollToSection('repositories')"
            class="nav-link"
            style="cursor: pointer"
            >Repositories</a
          >
        </li>
        <li>
          <a
            (click)="scrollToSection('dependency-injection')"
            class="nav-link"
            style="cursor: pointer"
            >Dependency Injection</a
          >
        </li>
        <li>
          <a
            (click)="scrollToSection('examples')"
            class="nav-link"
            style="cursor: pointer"
            >Examples</a
          >
        </li>
      </ul>

      <div class="cta-section">
        <button (click)="navigateToGenerator()" class="try-generator-btn">
          Try Generator
        </button>
      </div>
    </div>
  </nav>

  <!-- Main Content -->
  <main class="doc-content">
    <!-- Overview Section -->
    <section id="overview" class="doc-section">
      <h2>Overview</h2>
      <p class="section-intro">
        The Onion Initializr helps you create clean, maintainable frontend
        applications following the
        <a
          href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/"
          target="_blank"
          rel="noopener noreferrer"
          >Onion Architecture pattern</a
        >. It generates code for entities, repositories, services, and a
        dependency injection configuration neccessary to setup Onion
        Architecture Projects. The goal is to keep the central business logic as
        clean as possible. Dependency Injection is used for Inversion of Control
        (IoC) to achieve this. We use and advise Awilix as the Dependency
        Injection Framework because it allows for Dependency Injection without
        Annotations inside classes keeping the core clean.
      </p>
    </section>

    <!-- Getting Started Section -->
    <section id="getting-started" class="doc-section">
      <h2>Getting Started</h2>

      <h3>Quick Start</h3>
      <ol class="step-list">
        <li>Access the <a href="generator">Online Generator</a></li>
        <li>Configure your entities and services</li>
        <li>Select your preferred UI framework</li>
        <li>Choose dependency injection framework</li>
        <li>Generate and download your project</li>
      </ol>
    </section>

    <!-- Architecture Section -->
    <section id="architecture" class="doc-section">
      <h2>Onion Architecture Overview</h2>

      <div class="architecture-explanation">
        <p class="section-intro">
          Onion Architecture is a software design pattern that promotes loose
          coupling and high cohesion by organizing code into concentric layers,
          like the layers of an onion.
        </p>

        <h3>How It Works</h3>
        <p>
          The architecture consists of multiple layers arranged in a circular
          pattern, where each layer can only depend on layers closer to the
          center. This creates a natural dependency flow that keeps your
          business logic isolated and protected.
        </p>

        <h3>What Rings are there?</h3>
        <ul class="principle-list">
          <li>
            <strong>Domain (Core):</strong> Contains your business entities and
            core business rules - the heart of your application
          </li>
          <li>
            <strong>Domain Services:</strong> Business logic that doesn't
            naturally fit within a single entity
          </li>
          <li>
            <strong>Application Services:</strong> Orchestrate use cases and
            coordinate between domain and infrastructure
          </li>
          <li>
            <strong>Infrastructure:</strong> External concerns like databases,
            file systems, web APIs, and UI frameworks, Configs, Backends.
          </li>
        </ul>
      </div>
    </section>

    <!-- Entities Section -->
    <section id="entities" class="doc-section">
      <h2>Entities</h2>
      <p>
        Entities represent your core business objects. They contain the
        essential data and behavior of your domain. They have no outward
        dependencies.
      </p>

      <h3>Generated Entity Example</h3>
      <app-code-display
        filename="User.ts"
        content="/**
 * Domain Entity: User
 */
export class User {
  constructor() {
    // TODO: Define properties for User
  }
}">
      </app-code-display>

      <p>
        <strong>Note:</strong> The generator creates a basic entity structure.
        You'll need to add properties, constructor parameters, and business
        logic methods according to your domain requirements.
      </p>
    </section>

    <!-- Services Section -->
    <section id="services" class="doc-section">
      <h2>Services</h2>

      <h3>Domain Services</h3>
      <p>
        Contain business logic that doesn't naturally fit within a single
        entity. Domain services are generated with entity dependencies based on
        your configuration.
      </p>

      <app-code-display
        filename="UserService.ts"
        content='import { User } from "../Entities/User";

/**
 * Domain Service: UserService
*/
export class UserService {
  constructor(
  ) {}

  public exampleMethod(): void {
    // this.user...
  }
}'>
      </app-code-display>

      <h3>Application Services</h3>
      <p>
        Orchestrate use cases and coordinate between domain services and
        repositories. Generated with dependencies based on your configuration.
      </p>

      <app-code-display
        filename="UserManagementAppService.ts"
        content='import { UserService } from "../../Domain/Services/UserService";
import { IUserRepository } from "../../Domain/Interfaces/IUserRepository";

/**
 * Application Service: UserManagementAppService
*/
export class UserManagementAppService {
  constructor(
    private readonly userService: UserService,
    private readonly userRepository: IUserRepository,
  ) {}

  public async runExampleUseCase(): Promise<void> {
    const someEntity = await this.userRepository.findById("someId");
    
    // this.userService.exampleMethod();
  }
}'>
      </app-code-display>
    </section>

    <!-- Repositories Section -->
    <section id="repositories" class="doc-section">
      <h2>Repositories</h2>

      <h3>Repository Interface</h3>
      <p>
        Repository interfaces define contracts for data access in the Domain
        layer. Generated automatically for each entity.
      </p>

      <app-code-display
        filename="IUserRepository.ts"
        content='import { User } from "../Entities/User";

/**
 * Repository Interface: IUserRepository
*/
export interface IUserRepository {
    findAll(): Promise<User[] | null>;
    findById(id: string): Promise<User | null>;
    save(entity: User): Promise<void>;
    delete(id: string): Promise<void>;

    // TODO: Add more custom methods if needed
}'>
      </app-code-display>

      <h3>Repository Implementation</h3>
      <p>
        Repository implementations are generated in the Infrastructure layer and
        provide concrete logic.
      </p>

      <app-code-display
        filename="UserRepository.ts"
        content='import { User } from "../../Domain/Entities/User";
import { IUserRepository } from "../../Domain/Interfaces/IUserRepository";

/**
 * Repository: UserRepository
*/
export class UserRepository implements IUserRepository {
  public async findAll(): Promise<User[] | null> {
    // TODO: Implement retrieval from DB or other data source
    return [];
  }

  public async findById(id: string): Promise<User | null> {
    // TODO: Implement retrieval from DB or other data source
    console.log(&apos;findById in UserRepository called with id: &apos;, id);
    return null;
  }

  public async save(user: User): Promise<void> {
    // TODO: Implement persist logic
  }

  public async delete(id: string): Promise<void> {
    // TODO: Implement delete logic
  }

  // TODO: Add more methods if defined in IUserRepository
}'>
      </app-code-display>
    </section>

    <!-- Dependency Injection Section -->
    <section id="dependency-injection" class="doc-section">
      <h2>Dependency Injection Configuration</h2>

      <h3>Awilix Configuration</h3>
      <p>
        When you choose "awilix" as your DI framework, the generator creates a
        complete dependency injection configuration file that registers all your
        entities, repositories, and services.
      </p>

      <h4>Generated awilix.config.ts for E-commerce Example</h4>
      <app-code-display
        filename="awilix.config.ts"
        content='import { createContainer, asClass, InjectionMode } from "awilix";

import { User } from "../../Domain/Entities/User";
import { Product } from "../../Domain/Entities/Product";
import { Order } from "../../Domain/Entities/Order";
import { Payment } from "../../Domain/Entities/Payment";
import { UserRepository } from "../../Infrastructure/Repositories/UserRepository";
import { ProductRepository } from "../../Infrastructure/Repositories/ProductRepository";
import { OrderRepository } from "../../Infrastructure/Repositories/OrderRepository";
import { PaymentRepository } from "../../Infrastructure/Repositories/PaymentRepository";
import { UserService } from "../../Domain/Services/UserService";
import { ProductService } from "../../Domain/Services/ProductService";
import { OrderService } from "../../Domain/Services/OrderService";
import { PaymentService } from "../../Domain/Services/PaymentService";
import { OrderManagementAppService } from "../../Application/Services/OrderManagementAppService";
import { UserManagementAppService } from "../../Application/Services/UserManagementAppService";

const container = createContainer({ injectionMode: InjectionMode.CLASSIC });

container.register({
  user: asClass(User).singleton(),
  product: asClass(Product).singleton(),
  order: asClass(Order).singleton(),
  payment: asClass(Payment).singleton(),
  userRepository: asClass(UserRepository).singleton(),
  productRepository: asClass(ProductRepository).singleton(),
  orderRepository: asClass(OrderRepository).singleton(),
  paymentRepository: asClass(PaymentRepository).singleton(),
  userService: asClass(UserService).singleton(),
  productService: asClass(ProductService).singleton(),
  orderService: asClass(OrderService).singleton(),
  paymentService: asClass(PaymentService).singleton(),
  orderManagementAppService: asClass(OrderManagementAppService).singleton(),
  userManagementAppService: asClass(UserManagementAppService).singleton(),
});

export default container;'>
      </app-code-display>
      <h4>Using the container</h4>
      <p>
        No more linking needed. Awilix will resolve the correct Repository
        Implementation at Runtime. You call the Methods of the Interface. Awilix
        will inject the correct Implementation. Awilix injects the first
        Repository that implements the Interface.
      </p>
    </section>

    <!-- Examples Section -->
    <section id="examples" class="doc-section">
      <h2>Examples</h2>

      <h3>E-commerce Application</h3>
      <div class="example-card">
        <h4>Configuration</h4>
        <app-code-display
          filename="ecommerce-config.json"
          content='{
  "folderPath": "/path/to/ecommerce-project",
  "entities": ["User", "Product", "Order", "Payment"],
  "domainServices": ["UserService", "ProductService", "OrderService", "PaymentService"],
  "applicationServices": ["OrderManagementAppService", "UserManagementAppService"],
  "domainServiceConnections": {
    "UserService": ["User"],
    "ProductService": ["Product"],
    "OrderService": ["Order", "User", "Product"],
    "PaymentService": ["Payment", "Order"]
  },
  "applicationServiceDependencies": {
    "OrderManagementAppService": {
      "domainServices": ["OrderService", "PaymentService"],
      "repositories": ["IOrderRepository", "IPaymentRepository"]
    },
    "UserManagementAppService": {
      "domainServices": ["UserService"],
      "repositories": ["IUserRepository"]
    }
  },
  "uiFramework": "react",
  "diFramework": "awilix"
}'>
        </app-code-display>
      </div>

      <h3>Blog Application</h3>
      <div class="example-card">
        <h4>Configuration</h4>
        <app-code-display
          filename="blog-config.json"
          content='{
  "folderPath": "/path/to/blog-project",
  "entities": ["Author", "Post", "Comment", "Category"],
  "domainServices": ["AuthorService", "PostService", "CommentService"],
  "applicationServices": ["BlogManagementAppService"],
  "domainServiceConnections": {
    "AuthorService": ["Author"],
    "PostService": ["Post", "Author", "Category"],
    "CommentService": ["Comment", "Post", "Author"]
  },
  "applicationServiceDependencies": {
    "BlogManagementAppService": {
      "domainServices": ["PostService", "CommentService"],
      "repositories": ["IPostRepository", "ICommentRepository", "IAuthorRepository"]
    }
  },
  "uiFramework": "vue",
  "diFramework": "awilix"
}'>
        </app-code-display>
      </div>

      <h3>Generated Project Structure</h3>
      <div class="code-block">
        <pre><code>your-project/
├── src/
│   ├── Domain/
│   │   ├── Entities/
│   │   │   ├── User.ts
│   │   │   ├── Order.ts
│   │   │   └── Product.ts
│   │   └── Services/
│   │       ├── UserService.ts
│   │       └── OrderService.ts
│   ├── Application/
│   │   └── Services/
│   │       └── OrderManagementAppService.ts
│   └── Infrastructure/
│       ├── Configuration/
│       │   └── awilixConfig.ts
│       ├── Interfaces/
│       │   ├── IUserRepository.ts
│       │   ├── IOrderRepository.ts
│       │   └── IProductRepository.ts
│       └── Repositories/
│           ├── UserRepository.ts
│           ├── OrderRepository.ts
│           └── ProductRepository.ts
└── package.json</code></pre>
      </div>
    </section>
  </main>
</div>
